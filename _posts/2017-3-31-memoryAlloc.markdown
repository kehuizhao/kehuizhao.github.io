---
layout:     post
title:      "浅谈程序的内存分配"
subtitle:   "假装我有一套房..."
date:       2017-3-31 00:05:00
author:     "ThdLee"
header-img: "img/MemoryAlloc/post-bg-memoryAlloc.jpg"
catalog:    true
tags:
    - 操作系统
    - 编译原理
---

## 内存分配

尽管现在的许多高级语言已经不需要程序员去直接处理内存分配和垃圾回收，但是内存的管理是学习编程过程中的一个很重要的概念，理解相关概念和应用能够让我们对编程和计算机有更深的理解。

一般来讲，程序由下面几部分组成：

**栈**：局部变量以及每次函数调用时所需要保存的信息都存放在此区域中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后最近被调用的函数在栈上为其局部变量分配存储空间。

**堆**：堆用于存放程序运行中被动态分配的内存，大小并不固定。

**bss段**：也叫未初始化数据段，存放程序中未初始化过的全局变量和静态变量，在程序开始执行之前，内核将此段的数据初始化为0。

**数据段**：也叫初始化数据段，存放程序中已经明确地初始化的全局变量和静态变量。（如C程序中任何函数之外的声明）

**正文段**：存放程序的执行代码，它的大小在程序运行前就已经确定。通常，正文段是可以共享的，多个此程序执行的进程在内存中只需要一个副本。另外，正文段常常是只读的，以防止程序由于意外而修改指令。该段也可能包含一些只读的常数，如字符串常量等。

## 对C程序中内存布局的探索

> 所有程序均在Linux CentOS上运行。

### 数据段与bss段

运行下面代码，查看全局变量的地址（注释为对应地址）：

```c
#include <stdio.h>

int a = 0;
int b;
int main(int argc, const char * argv[]) {
    printf("%p\n", &a);		//0x601038
    printf("%p\n", &b);		//0x60103c
    return 0;
}
```

可以看到，未初始化的`b`的地址正好在初始化过的`a`的地址之上，这是巧合吗？我们再探索一下：

```c
#include <stdio.h>

int a = 3;
int b;
int c = 5;
int d;
int main(int argc, const char * argv[]) {
    printf("%p\n", &a);		//0x601034 
    printf("%p\n", &b);		//0x601044 
    printf("%p\n", &c);		//0x601038
    printf("%p\n", &d);		//0x601040
    return 0;
}
```
初始化的`a`和`c`在低地址，而`b`和`d`在高地址，所以说这并不是偶然。

另外，编译器通常对bss段的处理方式是：只描述大小，不增加目标文件体积。我们可以使用`size`命令来看一下编译后的`a.out`的各段大小，作为对比，我们先对一个没有声明任何函数和变量的程序执行`size`命名：

```
$ size a.out
```
```
   text	   data	    bss	    dec	    hex	filename
   1129	    540	      4	   1673	    689	a.out
```

接下来，我们声明一个未初始化的全局的数组`int a[65535];`：

```c
#include <stdio.h>
int bss[65535];
int main(int argc, const char * argv[]) {
    bss[0] = 1;
    return 0;
}
```
执行`size`:

```
   text	   data	    bss	    dec	    hex	filename
   1145	    540	 262176	 263861	  406b5	a.out

```

很明显，bss段变大了，再看一下`a.out`的大小：

```
$ ls -l a.out
```
```
-rwxr-xr-x. 1 thdlee thdlee 8848 5月  11 17:49 a.out
```

目标文件的大小远远小于65535个`int`，这次直接将数组赋一个初值`int bss[65535] = {1};`，再进行同样的操作：

```
$ size a.out
```
```
   text	   data	    bss	    dec	    hex	filename
   1129	 262708	      4	 263841	  406a1	a.out
```
```
$ ls -l a.out
```
```
-rwxr-xr-x. 1 thdlee thdlee 270680 5月  11 17:49 a.out
```

不出所料，data段增大了，文件也变成了应有的大小。

### 代码段

代码段的内存地址可以用函数指针来检测：

```c
#include <stdio.h>
void foo() {
}

int a;
int main(int argc, const char * argv[]) {
    printf("%p\n", &a);			\\0x601034
    printf("%p\n", &foo);		\\0x40052d
    return 0;
}
```

函数是存放在代码段的，所以看到函数的内存地址比数据区还要低。另外，文本区一般还存放着字符串常量，我们先来看看下面这个例子：

```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    char *a = "Hello World!";
    char *b = "Hello World!";
    char *c = "Hello";
    printf("%p\n", a);		\\0x400630
    printf("%p\n", b);		\\0x400630
    printf("%p\n", c);		\\0x40063d
    return 0;
}
```
从例子中可以看到，字符串的地址在与函数地址差不多的地方，而且对于指向相同字符串的指针变量，它们的地址是相同的。

### 堆和栈

一般来说，堆是由低地址向高地址增长的，而栈是由高地址向低地址增长。

按照惯例，我们还是用一个小程序来探索一下：

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, const char * argv[]) {
    int a = 1;
    int b = 2;
    char *p1 = malloc(16);
    char *p2 = malloc(16);
    printf("%p\n", &a);		\\0x7ffe145134dc
    printf("%p\n", &b);		\\0x7ffe145134d8
    printf("%p\n", p1);		\\0x1478010
    printf("%p\n", p2);		\\0x1478030
    free(p1);
    free(p2);
    return 0;
}
```

根据变量的声明顺序，可以看到栈是向下增长，而堆是向上增长的。这里要注意的一点是，指针`p1`和`p2`存储的是指向对的地址，但是它们两个的存储位置是在栈上的。我们再来看看函数调用中变量地址的变化。

```c
#include <stdio.h>

void foo2() {
    int c;
    printf("%p\n", &c);		\\0x7fffb97a99ec
}

void foo1() {
    int b;
    printf("%p\n", &b);		\\0x7fffb97a9a0c
    foo2();
}

void bar() {
    int d;
    printf("%p\n", &d);		\\0x7fffb97a9a0c
}

int main(int argc, const char * argv[]) {
    int a;
    printf("%p\n", &a);		\\0x7fffb97a9a3c
    foo1();
    bar();
    return 0;
}
```

随着函数的开始，栈也开始向下扩展。当函数结束时，分配在栈上的空间也跟着收回。

## 更进一步地探讨

至此，我们就会对程序中内存分配和管理有了一定的了解，但是程序中的内存地址是怎么来的呢？它们是计算机中的物理地址吗？如果不是，那又和物理地址有什么关系呢？

这几个问题牵扯到了**编译器**的和**操作系统**的一些相关知识，但对这些内容深入地探讨超出了本文的范围，因此本文只能尽量描述清楚其中的关系。

进入正题，编译器将代码转换为可执行程序时，必须为代码产生的各个值分别分配一个存储位置。编译器必须理解值的类型、长度、可见性和生命周期。编译器必须考虑一系列对代码的内存处理问题来定义一组约定来解决这些问题。

为分配存储，编译器必须理解全系统范围内对内存分配和使用的约定。编译器、操作系统和处理器协助，以确保多个程序能够以交错的方式（时间片）安全地执行。

除了创建栈，对于大多数语言，编译器都需要创建堆，以便为动态分配的数据结构提供内存。为保证高效地利用内存空间，堆和栈被置于开放空间的两端，彼此相向增长，所以就出现了我们所观察到的现象。当然，将堆和栈互换位置效果也是一样的。下图是单个程序编译后所用地址空间的典型布局，具体的实现和细节可能会因编译器和语言的不同而不同：

![逻辑地址的空间布局](http://thdlee.com/img/MemoryAlloc/logicalAddress.jpg)

这只是编译器的视角所看到的地址空间，编译器会为编译的每个程序分配一个独立的地址空间，让程序以为自己拥有独立的内存（其实也让程序员以为程序有独立的内存），其实这只是假象。在执行程序时，操作系统会将这些逻辑地址空间映射到处理器支持的物理地址空间中。

![地址空间的不同视图](http://thdlee.com/img/MemoryAlloc/addressSpace.jpg)

所以说，我们所看到的只是逻辑地址，我们在代码中对所谓内存的操作，也只是对逻辑地址的操作，这些操作的具体过程是由编译器和操作系统以及硬件为我们完成的。		