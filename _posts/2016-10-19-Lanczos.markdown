---
layout:     post
title:      "Lanczos算法放大和缩小图片"
subtitle:   "我的Java课程小作业"
date:       2016-10-19 22:30:00
author:     "ThdLee"
header-img: "img/Lanczos/post-bg-lanczos.jpg"
tags:
    - Java
    - 图像处理
---

由于最近的Java作业要求将图片放大缩小，主要就是选用一种插值算法，如最邻近插值、双线性二次插值、双线性三次插值，Lanczos插值算法等。本文主要讲如何用Java实现Lanczos算法,详细原理见[Lanczos Resampling](en.wikipedia.org/wiki/Lanczos_resampling)

Lanczos插值的原理其实就是在原图像中取一个小窗口，通过计算权重映射到新的图像中的一个像素点中。

权重计算公式如下:

![weight compute1](http://thdlee.com/img/Lanczos/Lanczos1.svg)

等同于:

![weight compute1](http://thdlee.com/img/Lanczos/Lanczos2.svg)

可以看出，对于一维的数组，这个窗口其实就是`−a ≤ x ≤ a`

然后根据如下公式取加权平均值:

![weight average](http://thdlee.com/img/Lanczos/Lanczos3.svg)

扩展到二维，权重计算为:

![2D weight compute](http://thdlee.com/img/Lanczos/Lanczos4.svg)

![2D weight average](http://thdlee.com/img/Lanczos/Lanczos5.svg)

可以看到窗口的大小就是`2a * 2a`。

![a](http://thdlee.com/img/Lanczos/LanczosA.png)

当`a = 2`时，该算法适合图像缩小，当`a = 3`时，该算法适合图像放大。

接下来是我用Java实现Lanczos插值(只支持了jpg、png和bmp格式的图片):

```java
public BufferedImage imageScale(String pathName, float widthScale, float heightScale) throws IOException {
	if (!pathName.endsWith("png") && !pathName.endsWith("jpg") && !pathName.endsWith("bmp")) {
		throw new RuntimeException("Wrrong File!");
	}
	File file = new File(pathName);
	BufferedImage bufferedImage = ImageIO.read(file);
		
	widthScale = 1/widthScale;
	heightScale = 1/heightScale;
	lanczosSize = widthScale > 1 ? 3 : 2;
	int srcW = bufferedImage.getWidth();
	int srcH = bufferedImage.getHeight();
	int destW = (int)(bufferedImage.getWidth() / widthScale);
	int destH = (int)(bufferedImage.getHeight() / heightScale);
	
	int[] inPixels = bufferedImage.getRGB(0, 0, srcW, srcH, null, 0, srcW);
	int[] outPixels = new int[destW * destH];

	for (int col = 0; col < destW; col++) {
			
			
		double x = col * widthScale; 
		double fx = (double)Math.floor(col * widthScale);
		for (int row = 0; row < destH; row ++) {
				
			double y = row * heightScale;
			double fy = (double)Math.floor(y);
			double[] argb = {0, 0, 0, 0};
			int[] pargb = {0, 0, 0, 0};
			double totalWeight = 0;
			//  计算窗口的权重	
			for (int subrow = (int)(fy - lanczosSize + 1); subrow <= fy + lanczosSize; subrow++) {
				if (subrow < 0 || subrow >= srcH) 
					continue;
					
				for (int subcol = (int)(fx - lanczosSize + 1); subcol <= fx + lanczosSize; subcol++) {
					if (subcol < 0 || subcol >= srcW)  
	                    continue;
						
					double weight = getLanczosFactor(x - subcol) * getLanczosFactor(y - subrow);
					
					if (weight > 0) { 
                        int index = (subrow * srcW + subcol); 
                        for (int i = 0; i < 4; i++)
                          	pargb[i] = (inPixels[index] >> 24 - 8 * i) & 0xff;
               	        totalWeight += weight; 
                        for (int i = 0; i < 4; i++)
                           	argb[i] += weight * pargb[i];
					}
				}
			}
			for (int i = 0; i < 4; i++)
				pargb[i] = (int)(argb[i] / totalWeight);
			outPixels[row * destW + col] = (clamp(pargb[0]) << 24) |
						(clamp(pargb[1]) << 16) |
						(clamp(pargb[2]) << 8) |
						clamp(pargb[3]);
		}
	}
		
	BufferedImage bufImg = new BufferedImage(destW, destH,
			pathName.endsWith("png") ? BufferedImage.TYPE_INT_ARGB : BufferedImage.TYPE_INT_RGB);
		
	bufImg.setRGB(0, 0, destW, destH, outPixels, 0, destW);
	return bufImg;
}
private int clamp(int v)  
{  
    return v > 255 ? 255 : (v < 0 ? 0 : v);  
}  
  
private double getLanczosFactor(double x) {  
    if (x >= lanczosSize)  
        return 0;   
    if (Math.abs(x) < 1e-16)  
        return 1;  
    x *= Math.PI; 
    return Math.sin(x) * Math.sin(x/lanczosSize) / (x*x);  
}  

```

我们来看一下处理效果:

![source](http://thdlee.com/img/Lanczos/SourcePicture.jpg "原图")
<small class="img-hint">原图</small>

![zoom out](http://thdlee.com/img/Lanczos/ZoomOutPicture.jpg "放大")
<small class="img-hint">放大</small>

![zoom in](http://thdlee.com/img/Lanczos/ZoomInPicture.jpg "缩小")
<small class="img-hint">缩小</small>
